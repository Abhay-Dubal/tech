

******************************************************************************************************************************************************************************************
										Commands
******************************************************************************************************************************************************************************************




					***************************************************************************************************
									Kubernetes Basic commands																	***************************************************************************************************


					


	1. install kubectl  , check using  (kubectl version)

	2. get context by using

					---------------------------------------------------------------------------
					|                 kubectl config current-context			  |     list a current cluster config is locating
					---------------------------------------------------------------------------
			A context element in a kubeconfig file is used to group access parameters under a convenient name. Each context has three parameters: cluster, namespace, and user. 			By default, the kubectl command-line tool uses parameters from the current context to communicate with the cluster


			use =>  kubectl config get-contexts  --- list all the cluster that are configured to master
	
	3. get list of nodes  , nodes are the hardware devices connected to kubenetes master where sheduler deploys container

					---------------------------------------------------------------------------
					|                  kubectl get nodes 					 				 |
					---------------------------------------------------------------------------

				deploy pod on only on specific node using node selector

					first lable the node as :
									1. get node name using get nodes command

									2. use label command to label the node like kubctl label node NODE_NAME KEY=VALUE

															e.g. kubectl label node node12 hardware=t2.medium

					then in yml file of manifest mention as

							spec:
								nodeSelector:
									hardware = t2.medium       # create pod on only instance/node having lable as key=hardware and value = t2.medium
							
						# if no node having this lable , then pod will not be deployed it will be in pending state


	4. get list of all pods avilable on every node

					---------------------------------------------------------------------------
					|          		       kubectl get pods									  | (kubectl get pod -o wide ) for detailed view
					---------------------------------------------------------------------------		
						kubectl get pod -o=custom-columns=NODE:.spec.nodeName,NAME:.metadata.name --all-namespaces   (from every clucter namespace)

						kubectl get pods -n NAME_OF_NAMESPACE          ---- get pods inside specific namespace

						kubectl get pods --show-labels                   ----- to get all the pods with labels , also can be used for any other services like rs , ns

					To reterve using any lable key Use :

						kubctl get pods -l key=value                 ---- also for other resources

						also  kubctl get pods -l key!=value              ---- get if key is not having value as value 

					set based selectors :

						kubectl get pods 'KEY in (value1,value2,value3)'    --- list the pods having key as value1 or value2 or value3

									also can be used with selector like notin and exist


	5. config file is located in        ==>     ${HOME_DIR}/${USER}/.kube/config

		config file contains cluster , user and context .

				cluster = > https endpoints for cluster
				user = >  credential to communicate to cluster
				context = >   cluster + user

	6. get list of services

					---------------------------------------------------------------------------
					|                  kubectl get services 				  |
					---------------------------------------------------------------------------

	7. get list of name spaces available
					---------------------------------------------------------------------------
					|                		 kubectl get ns				  |
					---------------------------------------------------------------------------

				Namespace provides an additional qualification to a resource name. This is helpful when multiple teams are using the same cluster and there is a potential of 				name collision. It can be as a virtual wall between multiple clusters.

				Functionality of Namespace
					Following are some of the important functionalities of a Namespace in Kubernetes âˆ’

												Namespaces help pod-to-pod communication using the same namespace.

												Namespaces are virtual clusters that can sit on top of the same physical cluster.

												They provide logical separation between the teams and their environments.

	8. get desciption of pod available
					---------------------------------------------------------------------------
					|     		kubectl describe pod POD_NAME -n NS_NAME		  | if NS_NAME is not mentioned then it search in all the availble ns
					---------------------------------------------------------------------------
												

	9. get all info about status and pods 

					---------------------------------------------------------------------------
					|              	 kubectl get all		 								  |
					---------------------------------------------------------------------------

	10. delete a pod from specific namespace
					---------------------------------------------------------------------------
					|         kubectl delete pod POD_NAME -n NS_NAME		 	 |    --- use -n only if 2 pods in diff ns have same name
					---------------------------------------------------------------------------


				delete pod using lable :

						kubectl delete pod -l key=value           ---- delete all the pods having lable as key and it value is value

	11. get logs inside pod for troubleshooting a problem causing sometimes failures

					---------------------------------------------------------------------------
					|           		 kubectl logs POD_NAME    						  |
					---------------------------------------------------------------------------

	12. assign label to a pod or any other resource

					---------------------------------------------------------------------------
					|           	kubectl lable Resource_TYPE Resource_NAME KEY=VALUE  		|
					---------------------------------------------------------------------------

					e.g.  kubectl lable pods mypod1 name=lable1


	







					***************************************************************************************************
									Kubernetes Deployment commands																	***************************************************************************************************

					Deployment is getting cluster from actual state to desired state at controlled rate

	1. build yaml file containg info to get in desired state known as manifest

		required details for manifest :

				apiVersion - Which version of the Kubernetes API you're using to create this object
				kind - What kind of object you want to create
				metadata - Data that helps uniquely identify the object, including a name string, UID, and optional namespace
				spec - What state you desire for the object

		it will create deployment(metadata -> name) and replica set named as mentioned in metadata -> name ,  like =>  name-rs_id-hash  

		Replica Set ensures how many replica of pod should be running. It can be considered as a replacement of replication controller. The key difference between the replica set 		and the replication controller is, the replication controller only supports equality-based selector whereas the replica set supports set-based selector.
		However, a Deployment is a higher-level concept that manages ReplicaSets and provides declarative updates to Pods along with a lot of other useful features
			You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define 			Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.


	2. apply yml file
					---------------------------------------------------------------------------
					|                kubectl apply -f /PATH_TO_FILE/FILENAME.yml 		  |
					---------------------------------------------------------------------------

	3. get list of replica sets available
					---------------------------------------------------------------------------
					|                		 kubectl get rs				  |   use --watch to see rs in real time , i.e. creating and deleting
					--------------------------------------------------------------------------- 


	4. get list of deployment
					---------------------------------------------------------------------------
					|                		 kubectl get deploy			  |  (kubectl delete deploy NAME)  to delete 
					--------------------------------------------------------------------------- 

	5. get desciption of deployment
					---------------------------------------------------------------------------
					|               kubectl describe deployments DEPLOY_NAME		  |   
					--------------------------------------------------------------------------- 
	6. get desciption of rs
					---------------------------------------------------------------------------
					|		 kubectl describe rs/RS_NAME  				|   
					--------------------------------------------------------------------------- 


				***************************************************************************************************
									Kubernetes configmap  , Volume , secrets														***************************************************************************************************

		In programming, we use env files or separate configuration files to store settings, configurations, or variables that are required to execute the program. In Kubernetes, we 		can use ConfigMaps to achieve the same functionality.
		A ConfigMap is a Kubernetes API object that can be used to store data as key-value pairs. Kubernetes pods can use the created ConfigMaps as a:

				Configuration file
				Environment variable
				Command-line argument

		ConfigMaps provides the ability to make applications portable by decoupling environment-specific configurations from the containers.

			* Importantly, ConfigMaps are not suitable for storing confidential data. They do not provide any kind of encryption, and all the data in them are
					 visible to anyone who has access to the file. (Kubernetes provides secrets that can be used to store sensitive information.)



		//** Setup cocnfigmap using yaml file


							* file can be of any format 
					-----------------------------------------------------------------------------------------------

				     	kubectl create configmap MAP_NAME --from-file ./PATH/TO/FILE/file_name.yml    
      	
					-----------------------------------------------------------------------------------------------

					it will create configmap named as MAP_NAME


				get list of configmaps available 

					---------------------------------------------------------------------------
					|                	kubectl get configmaps				  |
					---------------------------------------------------------------------------
										kubectl describe configmaps MAP_NAME  --to get properties in details about map_name

				view specific configmaps  

					---------------------------------------------------------------------------
					|                kubectl get configmaps MAP_NAME -o yaml		  |    output map as yaml file
					---------------------------------------------------------------------------


		//** Mount configmap to pods using manifest

			 containers:
  				- name: container-configmap
      				  image: nginx:1.7.9
 	
      				  volumeMounts:
		
				# ----------  Using directly attached Volume  ---------# 
       					 - name: example-configmap-volume1
            				  mountPath: /etc/config   

				# ----------  Using configmap  ---------# 
       					 - name: example-configmap-volume2
            				  configMap:
						name: MAP_NAME     # from   kubectl get configmaps	 

				# ----------  Using secreat  ---------# 


				volumes:
      				 - name: secret-volume
        			  secret:       # treats like secreat only 
          			    secretName: mysecret            # mysecreat is a name like configmap
      				 - name: config-volume
        			    configMap:
          			      name: example-config #name of our configmap object



		//** secreats using cli
	
				kubectl apply -f /path/screats/secreat.yaml            ----using apply method , also configmap can be created this way just changing file and dir name
												(also kubectl create secreat command can be used like configmap )

				get list of secreats available 

					---------------------------------------------------------------------------
					|                	kubectl get secreats				  |
					---------------------------------------------------------------------------

		


				***************************************************************************************************
									Kubernetes replica and load-balancing														
				***************************************************************************************************


		there will be always at least replica no of pods will be in created/stared state 

		it can not be created using kind : pod , it requires kind Deployment or ReplicationController 


			sacle up/down ReplicationController using 

					kubctl scale --replicas=10 rc -l key=value     ---- key should be from only spec -> selector of that ReplicationController


					to delete ReplicationController or any object deployment use 

					kubectl delete -f FILENAME.yaml   --- it will not delete file physically only resource will be terminated from kubectl

















	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------



	7. e.g
					---------------------------------------------------------------------------
					|                			  |
					---------------------------------------------------------------------------









